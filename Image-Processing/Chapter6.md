# Image Filter
## Filter
입력 값에서 원하지 않는 값은 걸러내고 원하는 결과만을 얻는다는 의미로 쓰임
1. 영상의 품격을 높임
2. ** Edge를 검출하고 엣지의 방향을 알아냄 **
> 객체 인식과 분리의 기본이 되는 정보를 계산하고 수행

### 영상처리
새로운 영상을 얻기 위해 기존 픽셀 값에 어떠한 연산을 가해서 새로운 픽셀 값을 얻는 작업

## 공간영역필터; spatial domain filter
기존 픽셀 값 하나가 아닌 그 픽셀과 주변 픽셀들의 값을 활용하는 방법
## 주파수영역필터; frequency domain filter
픽셀 값들의 차이를 주파수로 변환해서 활용하는 방법

## Convolution
공간 영역 필터의 핵심 <br>
### n x n Kernal
window; filter; mask

커널의 각 요소와 대응하는 입력 픽셀 값을 곱해서 모두 합한 것을 결과 픽셀 값으로 결정하고, 이것을 마지막 픽셀까지 반복하는 것
```.py
cv2.filter2D()
# e.g.
dst = cv2.filter2D(src, ddepth, kernel{, dst, anchor, delta, borderType})
```
## Blurring; smoothing
영상을 초점이 맞지 않은 것처럼 흐릿하게 만드는 것
* 가장 쉬운 방법: 주변 픽셀 값들의 평균을 적용하는 것
<br> -> 픽셀 값의 차이가 적어져서 이미지가 흐릿해짐
> cv2.blur
커널의 크기만 지정하면 알아서 평균 커널을 생성해서 블러링을 적용한 영상으로.. 일반적으로 커널의 크기는 일반적으로 홀수!
> cv2.boxFilter

if normalize 인자 <br>
== TRUE blur()함수와 같은 역할 <br>
== FALSE 커널 영역의 모든 픽셀의 합을 구하게 됨 : 밀도를 이용한 객체 추적 알고리즘에 사용

## Gaussian blur
> Gaussian Distribution = NormD
* 평균이 아닌 가우시안 분포를 갖는 커널로 블러링을 하는 것 <br>
* 중앙 값이 가장 크고 멀어질수로 그 값이 작아지는 커널을 사용하는 것을 말함
* 새로운 픽셀 값 설정시 대상 픽세렝 가까울수록 많은 영향을 줘서 원래의 영상과 비슷하면서도 노이즈를 제거하는 효과가 있다.
```.py
cv2.GaussianBlur(src, ksize, sigmaX[, sigmaY, borderType])
# p.221
cv2.filter2D() = cv2.getGaussiankernel()
cv2.GaussianBlur() #노이즈제거!! 
```

## Median Blurring
커널 영역픽셀 값 중에 중간 값을 대상 픽셀 값으로 선택하는 것
* 특) 기존 픽셀 값 중에 하나를 선택하므로 기존 값을 재활용한다는 특징 <br> Salt and Pepper 잡음 제거에 효과적
```cv2.medianBlur()```
## Bilateral
* 등장배경) 블러링 필터는 대체로 잡음을 제거하는 데 효과가 있지만 edge도 흐릿하게 만드는 문제가 있음
* 장점) 이 필터는 이 문제를 개선하기 위해 가우시안 필터와 경계 필터 2개를 사용 <br> => 노이즈x 경계가 비교적 또렷
* 단점) 속도가 느림
-----------
## Edge 검출
배경과 전경을 분리하는 데 가장 기본적인 작업 (객체 인식과 추적의 첫 걸음)

### 샤프닝: 경계를 선명하게, 검출해서 경계에 있는 픽셀만을 골라서 강조함
> Magnitude: 엣지의 강도
Gradient direction ㅗ Edge direction

## 필터
### 로버츠 교차 필터 (Lawrence Roberts, 1963)
* 특징: 기본 미분 커널을 개선한 커널 제안
* 장점: 대각선 방향으로 1과 -1을 배치해서 사선 경계 검출 효과 높임
* 단점: 노이즈에 민감하고 엣지 강도가 약함
### 프리윗 필터 (Judith M.S. Prewitt)
* 특징: 각 방향으로 차분 세번 계산
* 장점: 엣지 강도가 강함, 수직.수평 엣지를 동등하게 찾음
* 단점: 대각선 검출 약함
### 소벨 필터 (Irwin Sobel, 1968)
* 특징: 중심 픽셀의 차분 비중을 두 배로 줌
* 장점: 수평, 수직 대각선 경계 검출에 모두 강한 마스크 <br> 가장 대표적인 1차 미분 마스크 ```cv2.sobel```
* 단점: 커널의 크기가 작은 경우 || 커널의 크기가 커도 그 중심에서 멀어질 수록 엣지 방향성의 정확도가 떨어짐
### 샤르필터 (Scharr)
* 특징: 소벨 필터의 단점을 개선함
### 라플라시안 필터 (Laplacian)---oh's p.125
* 장점: 2차 미분시 경계를 좀 더 정확히 검출
``` cv2.Laplacian() ```
* 주의: 노이즈에 민감하므로 사전에 가우시안 필터로 노이즈 제거 후 사용

### 캐니 엣지 (John F.Canny, 1986)
1. 노이즈 제거: 5X5 가우시안 블러링 필터로 노이즈 제거
2. 소벨 마스크로 엣지그레디언트 방향 계산: 소벨 마스크로 엣지 및 그레디언트 방향 검출
3. 비최대치 억제: 그레디언트 방향에서 검출된 엣지 중에 가장 큰 값만 선택하고 나머지 제거
4. 이력 스레스 홀딩: 두 개의 경계값(Max, Min) 지정해서 경계 영역에 있는 픽셀들 중 큰 경계 값 밖의 픽셀과 연결성이 없는 픽셀 제거

* 장점: 경계 검출 결과가 뛰어나고 스레시 홀드 값의 지정에 따라 경계 검출 대상을 조정할 수 있어서 가장 많이 사용하는 함수

## Morphology
* 노이즈 제거, 구멍 메꾸기, 연결되지 않은 경계 이어붙이기 등 형태학적 관점에서의 영상 연산
* 대상: 바이너리 이미지
* 대표적 연산
    * 침식
    * 팽창
    * 두 개 결합한 열림과 닫힘
### 침식(erosion)
* 객체의 영역을 깎아내는 연산
* 구조화요소(structuring element) 필요
    * 0과 1로 채워진 커널; 1이 채워진 모양에 따라 사각형, 타원형, 십자형 등을 사용 
* 구조화 요소 커널을 입력 영상에 적용해서 1로 채워진 영역을 온전히 올려 놓을 수 없으면 해당 픽셀을 0으로 변경함
* 구조화요소 커널 생성 함수 ```cv2.getStructuringElement()```
* 침식 연산 함수 ```cv2.erode()```
* 특징: 큰 물체는 주변을 깎아서 작게 만들지만 작은 객체는 아예 사라지게 만들 수 있으므로 아주 작은 노이즈를 제거하거나 원래는 따로 떨어진 물체인데 겹쳐져서 하나의 물체로 보일 때 서로를 떼어내는 데도 효과적임 (?!)
### 팽창(dilatation)
* 영상 속 사물의 주변을 덧붙여서 영역을 더 확장하는 연산
* 구조화 요소 커널을 입력 영상에 적용해서 1로 채워진 영역이 온전히 덮이지 않으면 1로 채워넣음
* 팽창 연산 함수 ```cv2.dilate()```

#### 침식과 팽창 연산은 밝은 부분이나 어두운 부분의 점 노이즈를 없애는 데 효과적이지만 모양의 변형이 일어남
하지만 이 연산들을 조합하면 원래의 모양을 유지하면서 노이즈만 제거가 가능함
* 열림 연산 = 침식 연산 -> 팽창 연산
주변보다 밟은 노이즈 제거에 효과적이면서 맞닿아 있는 것으로 보이는 독립된 개체를 분리하거나 돌출된 픽셀 제거에 효과적
* 닫힘 연산 = 팽창 연산 -> 침식 연산
주변보다 어두운 노이즈 제거에 효과적이면서 끊어져 보이는 개체를 연결하거나 구멍을 메우는 데 효과적
> 그레디언트 연산 = 팽창 - 침식
탑햇 = 원본 - 열림
블랙햇 = 닫힘 - 원본

## Image Pyramids
* 영상의 크기를 단계적으로 축소 또는 확대해서 피라미드처럼 쌓아 놓는 것
   * 영상을 분석할 때 먼저 작은 이미지로 빠르게 훑어보고 다음 단계 크기의 영상으로 분석하는 식으로 정확도를 높이는 것이 효율적
   * 영상의 크기에 따라 분석하는 내용이 다를 수 있기 때문
### 가우시안 피라미드
가우시안 필터를 적용한 후에 이미지 피라미드를 구현하는 것
```
dst = cv2.pyrDown()
```
가우시안 필터를 적용하고 나서 모든 짝수 행과 열을 삭제해서 입력 영상의 1/4 크기로 축소

```
dst = cv2.pyrUp()
```
0으로 채워진 짝수 행과 열을 새롭게 삽입하고 나서 가우시안 필터로 컨볼루션을 수행해서 주변 픽셀과 비슷하게 만드는 방법으로 4배 확대함
### 라플라시안 피라미드
* 영상의 복원과 경계 검출에 활용 가능
* 원본과 cv2.pyUp()함수를 적용한 영상의 차이를 단계별로 모아두는 것
   * pyUp()은 4배로 확대할 때 없던 행과 열을 생성해서 가우시안 필터를 적용하므로 원래의 영상만큼 완벽하지 못함
   * 그래서 pyDown()으로 한 단계 작아진 영상을 pyUp()으로 확대해도 원래의 영상을 완벽히 복원할 수 없음
   * 원본영상 - pyUp() 하면 그만큼이 원본과 확대본의 차이가 되는데 이걸 보관해놨다가 확대 영상에 더하면 원본을 완벽히 복원 가능.
